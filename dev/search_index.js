var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Creating-UnitfulScalars","page":"Guide","title":"Creating UnitfulScalars","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Unitful scalars can be defined using the u-prefixed non-standard string literals, e. g.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Ry = 1.21104020061 * u\"H*Mg*N*K*Pa*S*Tb*Tl*W/(Ba*C*Es*P*Pb*Pm*Ra*V*Yb)\"\nƒß = 1054.571818 * u\"P/PP*pP*ppm*m*M/MM*Mm*mm\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"They are parsed by Unitful.jl and then converted to a UnitfulScalar.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Don't try to use units defined on interval or logarithmic scales, such as ¬∞C or dBm. Use K and mW instead.","category":"page"},{"location":"guide/#Creating-UnitfulTensors","page":"Guide","title":"Creating UnitfulTensors","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"There are two ways to create UnitfulTensors. You can first construct an array of UnitfulScalars","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[1u\"s\" 2u\"s\"\n 3u\"s\" 4u\"s\"]","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"and then convert it to a UnitfulTensor","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"UnitfulTensor([1u\"s\" 2u\"s\"\n               3u\"s\" 4u\"s\"])","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Or you can construct an array of numbers and AxesDimensions separately and then combine them into a UnitfulTensor:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"vals = [1. 2.\n\t3. 4.]\ndims = ùêì * nodims(2, 2)\nUnitfulTensor(vals, dims)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In the latter case, numerical values should be given in SI units.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Unitless quantities and arrays thereof don't have to be wrapped in a UnitfulScalar or UnitfulTensor, but trying to do mixed unitful/unitless arithmetic with something other than Arrays (e. g., sparse matrices or StaticArrays) can result in method ambiguities. They are easily fixed if necessary.","category":"page"},{"location":"guide/#Creating-AxesDimensions","page":"Guide","title":"Creating AxesDimensions","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"AxesDimensions represent the physical dimensions of a UnitfulTensor and can be constructed as a tensor product of one-dimensional AxesDimensions:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"AxesDimensions([ùêì, ùêã, ùêã, ùêã]) ‚äó AxesDimensions(inv.([ùêì, ùêã, ùêã, ùêã]))","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"or using nodims and scalar multiplication","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"ùêì * nodims(2, 2)\n# or dimensions(u\"s\") * nodims(2, 2)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"for dimensionally homogeneous UnitfulTensors.","category":"page"},{"location":"guide/#Defining-functions-of-UnitfulTensors","page":"Guide","title":"Defining functions of UnitfulTensors","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Functions of UnitfulTensors generally act on the numerical values and dimensions independently (with some exceptions, such as pivoted factorizations). If you use a function from some package (or Julia Base) that is not implemented in UnitfulTensors.jl, you can implement it yourself.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"For example, reversing a UnitfulTensor along a specific dimension could be done like this:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using UnitfulTensors\nimport Base: reverse\n\nfunction reverse(A::UnitfulTensor; kwargs...)\n    dims = reverse(dimensions(A); kwargs...)\n    vals = reverse(values(A); kwargs...)\n    return UnitfulTensor(vals, dims)\nend\n\nfunction reverse(A::AxesDimensions; dims)\n    d = dims\n    scale, Adims... = dimsplat(A)\n    newscale = scale * last(Adims[d]) # because AxisDimensions are normalized\n    newdims = (Adims[1:d-1]..., reverse(Adims[d]), Adims[d+1:end]...)\n    return AxesDimensions(newdims, newscale)\nend\n\nfunction reverse(A::AxisDimensions)\n    dims = dimsvec(A)\n    newdims = reverse(dims) ./ last(dims) # normalization\n    return AxisDimensions(newdims)\nend","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Note that due to the tensor product structure of AxesDimensions dealing with dimensions is usually much easier than with numerical values.","category":"page"},{"location":"guide/#Pitfalls","page":"Guide","title":"Pitfalls","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The types defined in this package store references to arrays of AbstractDimensions. Don't mutate them, or there will be surprises:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> Z = UnitfulTensor([1u\"S\" 2u\"S\"\n                          3u\"S\" 4u\"S\"])\n       V = UnitfulTensor([5u\"V\", 6u\"V\"])\n       I = Z * V\n2-element UnitfulVector{Float64, SIDimensions, Vector{Float64}, AxesDimensions{1, SIDimensions}}:\n 17.0 A\n 39.0 A\n \njulia> dimsvec(normdims(Z)[1])[2] = dimensions(u\"V\")\n       I\n2-element UnitfulVector{Float64, SIDimensions, Vector{Float64}, AxesDimensions{1, SIDimensions}}:\n           17.0 A\n 39.0 kg m^2 s^-3","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Make a copy instead if necessary.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Currently dimensions are compared with == for performance reasons, even though they are represented as floating-point numbers. As a consequence, units with integer, half-integer, quarter-integer exponents work, while units like s^(1/3) don't:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> 1u\"s^(2/3)\" + 1u\"s\" / 1u\"s^(1/3)\"\nERROR: DimensionMismatch: dimensions (ùêì^11184811/16777216, ùêì^5592405/8388608) do not match","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"This will be fixed when I figure out how to switch to ‚âà without a significant performance penalty.","category":"page"},{"location":"guide/#Beyond-SI","page":"Guide","title":"Beyond SI","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"By default, UnitfulTensors.jl converts all quantities into SI units upon construction. These units are provided by the upreferred function from Unitful.jl. It is possible to override this behaviour and define custom units by mechanisms described in the Unitful.jl documentation.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Example:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"import Unitful\n\nconst var\"@uu_str\" = Unitful.var\"@u_str\"\nUnitful.@unit ƒßunit \"ƒß\" ReducedPlanck Unitful.ƒß false\nUnitful.@unit eunit \"e\" ElementaryCharge Unitful.q false\nUnitful.register(@__MODULE__)\n_uT = ƒßunit/uu\"meV\"; _uL = uu\"nm\"; _uM = ƒßunit*_uT/_uL^2; _uI = eunit/_uT \nUnitful.preferunits(_uT, _uL, _uM, _uI)\n\nusing UnitfulTensors\n\nœÉ = 1u\"Œ©^-1\"; œâ = 1u\"THz2œÄ\"; E = 1u\"eV\"; vF = 1e6u\"m/s\"\nœÉ, œâ, E / vF\n\n# output\n\n(4108.235902227661 e^2 ƒß^-1, 4.135667696923859 meV ƒß^-1, 1.5192674478786259 ƒß nm^-1)","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"However, this is not recommended unless really necessary. This feature has not been tested extensively and it is better to stick to SI for consistency.","category":"page"},{"location":"guide/#Simplified-UnitfulTensor-construction","page":"Guide","title":"Simplified UnitfulTensor construction","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If you feel lazy to wrap all array literals in UnitfulTensor(...), you can call tensorize_literals(). After that, array literals containing UnitfulScalars will return UnitfulTensors instead of Arrays.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using UnitfulTensors\n\ntensorize_literals()\n\n[1u\"s\" 2\n 3     4u\"s^-1\"]\n \n# output\n\n2√ó2 UnitfulMatrix{Float64, SIDimensions, Matrix{Float64}, AxesDimensions{2, SIDimensions}}:\n 1.0 s       2.0\n   3.0  4.0 s^-1","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"note: Note\nThis feature is experimental. It might break something and may be removed in the future.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Scalar-API","page":"API","title":"Scalar API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"‚Äã‚ÄÅTypes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractUnitfulScalar\nUnitfulScalar\nAbstractDimensions\nSIDimensions","category":"page"},{"location":"api/#UnitfulTensors.FastQuantities.AbstractUnitfulScalar","page":"API","title":"UnitfulTensors.FastQuantities.AbstractUnitfulScalar","text":"AbstractUnitfulScalar{TV, TD<:AbstractDimensions} <: Number\n\nAbstract type representing a scalar physical quantity with a numerical value of type TV and physical dimensions of type TD.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.FastQuantities.UnitfulScalar","page":"API","title":"UnitfulTensors.FastQuantities.UnitfulScalar","text":"UnitfulScalar{TV, TD<:AbstractDimensions} <: AbstractUnitfulScalar{TV, TD}\n\nConcrete type representing a scalar physical quantity with a numerical value of type TV and physical dimensions of type TD.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.FastQuantities.AbstractDimensions","page":"API","title":"UnitfulTensors.FastQuantities.AbstractDimensions","text":"AbstractDimensions\n\nAbstract type representing the dimensions of a physical quantity.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.FastQuantities.SIDimensions","page":"API","title":"UnitfulTensors.FastQuantities.SIDimensions","text":"SIDimensions\n\nConcrete type storing the dimensions of a physical quantity as 7 Float32 exponents of SI base units.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constants","page":"API","title":"‚Äã‚ÄÅConstants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"NoDims","category":"page"},{"location":"api/#UnitfulTensors.FastQuantities.NoDims","page":"API","title":"UnitfulTensors.FastQuantities.NoDims","text":"NoDims\n\nPhysical dimensions of a dimensionless quantity.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Functions","page":"API","title":"‚Äã‚ÄÅFunctions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"value\nvalues(::AbstractUnitfulScalar)\ndimensions(::AbstractUnitfulScalar)\ndimexps","category":"page"},{"location":"api/#UnitfulTensors.FastQuantities.value","page":"API","title":"UnitfulTensors.FastQuantities.value","text":"value(x::AbstractUnitfulScalar)\n\nGet the numerical values of an AbstractUnitfulScalar in the default unit system (SI).\n\nSee also: values, dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.values-Tuple{AbstractUnitfulScalar}","page":"API","title":"Base.values","text":"values(x::AbstractUnitfulScalar)\n\nSame as value, for consistency with AbstractUnitfulTensor.\n\nSee also: dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.FastQuantities.dimensions-Tuple{AbstractUnitfulScalar}","page":"API","title":"UnitfulTensors.FastQuantities.dimensions","text":"dimensions(x::AbstractUnitfulScalar)\n\nGet the physical dimensions of an AbstractUnitfulScalar.\n\nSee also: value.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.FastQuantities.dimexps","page":"API","title":"UnitfulTensors.FastQuantities.dimexps","text":"dimexps(x::AbstractDimensions)\n\nRepresent x as a product of base dimensions raised to some powers and return a tuple of these powers.\n\nFor SIDimensions, the base dimensions are time, length, mass, current, temperature, amount, luminous intensity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tensor-API","page":"API","title":"Tensor API","text":"","category":"section"},{"location":"api/#Basic-types","page":"API","title":"‚Äã‚ÄÅBasic types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractUnitfulTensor\nUnitfulTensor\nAbstractAxesDimensions\nAxesDimensions\nAbstractAxisDimensions\nAxisDimensions","category":"page"},{"location":"api/#UnitfulTensors.AbstractUnitfulTensor","page":"API","title":"UnitfulTensors.AbstractUnitfulTensor","text":"AbstractUnitfulTensor{T<:AbstractUnitfulScalar, N} <: AbstractArray{T, N}\n\nAn N-dimensional array of unitful quantities of type T that can be used in linear or multilinear algebra.\n\nThis requirement forces its physical dimensions, represented by AbstractAxesDimensions, to factorize into a tensor product of dimensions along each axis, represented by AbstractAxisDimensions. For example, the physical dimensions of an AbstractUnitfulMatrix are the product of its row and column dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.UnitfulTensor","page":"API","title":"UnitfulTensors.UnitfulTensor","text":"UnitfulTensor{N, TV, TD<:AbstractDimensions,\n                 V <: Union{AbstractArray{TV, N}, AbstractQ{TV}},\n                 D <: AbstractAxesDimensions{N, TD}} <:\n                 AbstractUnitfulTensor{UnitfulScalar{TV, TD}, N}\n\nAn N-dimensional array of unitful quantities that can be used in linear or multilinear algebra.\n\nThis requirement forces its physical dimensions, represented by AxesDimensions, to factorize into a tensor product of dimensions along each axis, represented by AxisDimensions. For example, the physical dimensions of a UnitfulMatrix are the product of its row and column dimensions.\n\nUnitfulTensor stores its numerical values as an array of type V and its dimensions as an AbstractAxesDimensions of type D. They can be obtained using values and dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractAxesDimensions","page":"API","title":"UnitfulTensors.AbstractAxesDimensions","text":"AbstractAxesDimensions{N, T<:AbstractDimensions} <: AbstractArray{T, N}\n\nRepresents the physical dimensions of an N-dimensional AbstractUnitfulTensor.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AxesDimensions","page":"API","title":"UnitfulTensors.AxesDimensions","text":"AxesDimensions{N, T<:AbstractDimensions} <: AbstractAxesDimensions{N, T}\n\nRepresents the physical dimensions of an N-dimensional UnitfulTensor.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractAxisDimensions","page":"API","title":"UnitfulTensors.AbstractAxisDimensions","text":"AbstractAxisDimensions{T<:AbstractDimensions} <: AbstractVector{T}\n\nRepresents the physical dimensions of an AbstractUnitfulTensor along some axis.\n\nUsed as a building block of AbstractAxesDimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AxisDimensions","page":"API","title":"UnitfulTensors.AxisDimensions","text":"AxisDimensions{T<:AbstractDimensions} <: AbstractAxisDimensions{T}\n\nRepresents the physical dimensions of a UnitfulTensor along some axis.\n\nUsed as a building block of AxesDimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Extra-types","page":"API","title":"‚Äã‚ÄÅExtra types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AdjointAxesDimensions\nAbstractUnitfulFactorization\nUnitfulFactorization\nUnitfulGeneralizedFactorization","category":"page"},{"location":"api/#UnitfulTensors.AdjointAxesDimensions","page":"API","title":"UnitfulTensors.AdjointAxesDimensions","text":"AdjointAxesDimensions{T<:AbstractDimensions, P<:AbstractVecOrMatDimensions{T}} <:\n                      AbstractMatrixDimensions{T}\n\nLike LinearAlgebra.Adjoint and LinearAlgebra.Transpose, but for AbstractAxesDimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractUnitfulFactorization","page":"API","title":"UnitfulTensors.AbstractUnitfulFactorization","text":"AbstractUnitfulFactorization{T}\n\nUnitful version of LinearAlgebra.Factorization{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.UnitfulFactorization","page":"API","title":"UnitfulTensors.UnitfulFactorization","text":"UnitfulFactorization{TV, TD, F<:Factorization{TV}, D<:AbstractMatrixDimensions{TD}} <:\n                        AbstractUnitfulFactorization{UnitfulScalar{TV, TD}}\n\nFactorization of an AbstractUnitfulMatrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.UnitfulGeneralizedFactorization","page":"API","title":"UnitfulTensors.UnitfulGeneralizedFactorization","text":"UnitfulGeneralizedFactorization{TV, TD,\n                        F<:Factorization{TV},\n                        D<:Tuple{Vararg{AbstractMatrixDimensions{TD}}}\n                        } <:\n                        AbstractUnitfulFactorization{UnitfulScalar{TV, TD}}\n\nGeneralized factorization of two AbstractUnitfulMatrices.\n\n\n\n\n\n","category":"type"},{"location":"api/#Type-aliases","page":"API","title":"‚Äã‚ÄÅType aliases","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractUnitfulVector\nUnitfulVector\nAbstractUnitfulMatrix\nUnitfulMatrix\nAbstractVectorDimensions\nAbstractMatrixDimensions\nAdjointVectorDimensions\nAdjointMatrixDimensions","category":"page"},{"location":"api/#UnitfulTensors.AbstractUnitfulVector","page":"API","title":"UnitfulTensors.AbstractUnitfulVector","text":"AbstractUnitfulVector{T<:AbstractUnitfulScalar}\n\nAlias for AbstractUnitfulTensor{T, 1}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.UnitfulVector","page":"API","title":"UnitfulTensors.UnitfulVector","text":"UnitfulVector{TV, TD<:AbstractDimensions}\n\nAlias for UnitfulTensor{1, TV, TD}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractUnitfulMatrix","page":"API","title":"UnitfulTensors.AbstractUnitfulMatrix","text":"AbstractUnitfulMatrix{T<:AbstractUnitfulScalar}\n\nAlias for AbstractUnitfulTensor{T, 2}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.UnitfulMatrix","page":"API","title":"UnitfulTensors.UnitfulMatrix","text":"UnitfulMatrix{TV, TD<:AbstractDimensions}\n\nAlias for UnitfulTensor{2, TV, TD}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractVectorDimensions","page":"API","title":"UnitfulTensors.AbstractVectorDimensions","text":"AbstractVectorDimensions{T<:AbstractDimensions}\n\nAlias for AbstractAxesDimensions{1, T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AbstractMatrixDimensions","page":"API","title":"UnitfulTensors.AbstractMatrixDimensions","text":"AbstractMatrixDimensions{T<:AbstractDimensions}\n\nAlias for AbstractAxesDimensions{2, T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AdjointVectorDimensions","page":"API","title":"UnitfulTensors.AdjointVectorDimensions","text":"AdjointVectorDimensions{T<:AbstractDimensions}\n\nAlias for AdjointAxesDimensions{T, P} where P <: AbstractVectorDimensions{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnitfulTensors.AdjointMatrixDimensions","page":"API","title":"UnitfulTensors.AdjointMatrixDimensions","text":"AdjointMatrixDimensions{T<:AbstractDimensions}\n\nAlias for AdjointAxesDimensions{T, P} where P <: AbstractMatrixDimensions{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constructors","page":"API","title":"‚Äã‚ÄÅConstructors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"UnitfulTensor(::AbstractArray)\nAxesDimensions(A::AbstractArray{<:AbstractDimensions})\nAxesDimensions(dims, scale; normalize = true)\nAxisDimensions(dims::AbstractVector{<:AbstractDimensions}; normalize = true)","category":"page"},{"location":"api/#UnitfulTensors.UnitfulTensor-Tuple{AbstractArray}","page":"API","title":"UnitfulTensors.UnitfulTensor","text":"UnitfulTensor(A::AbstractArray)\n\nConvert an AbstractArray of UnitfulScalars or Numbers to a UnitfulTensor, which enables efficient operations on the physical dimensions.\n\nThe physical dimensions of A must factorize into a tensor product of dimensions along each axis (e. g., row and column dimensions of a matrix). Other arrays cannot be used in linear or multilinear algebra and will throw an error when attempting to convert them to a UnitfulTensor.\n\nExamples:\n\njulia> A = UnitfulTensor([1.0     2.0u\"s^-1\"\n                          3.0u\"J\" 4.0u\"W\"   ])\n2√ó2 UnitfulMatrix{Float64, SIDimensions, Matrix{Float64}, AxesDimensions{2, SIDimensions}}:\n             1.0         2.0 s^-1\n 3.0 kg m^2 s^-2  4.0 kg m^2 s^-3\n\njulia> V = values(A)\n2√ó2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> D = dimensions(A)\n2√ó2 AxesDimensions{2, SIDimensions}:\n     NoDims        ùêì^-1\n ùêã^2 ùêå ùêì^-2  ùêã^2 ùêå ùêì^-3\n\njulia> A == UnitfulTensor(V, D)\ntrue\n\njulia> inv(A)\n2√ó2 UnitfulMatrix{Float64, SIDimensions, Matrix{Float64}, AxesDimensions{2, SIDimensions}}:\n  -2.0   1.0 s^2 kg^-1 m^-2\n 1.5 s  -0.5 s^3 kg^-1 m^-2\n\njulia> inv(V)\n2√ó2 Matrix{Float64}:\n -2.0   1.0\n  1.5  -0.5\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.AxesDimensions-Tuple{AbstractArray{<:AbstractDimensions}}","page":"API","title":"UnitfulTensors.AxesDimensions","text":"AxesDimensions(A::AbstractArray{<:AbstractDimensions})\n\nConvert an AbstractArray of physical dimensions to AxesDimensions, which enables efficient operations on the dimensions of unitful arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.AxesDimensions-Tuple{Any, Any}","page":"API","title":"UnitfulTensors.AxesDimensions","text":"AxesDimensions(dims, scale; normalize = true)\nAxesDimensions(dims; normalize = true)\n\nAssemble AxesDimensions from the physical dimensions along each axis (dims) and an overall scalar factor (scale).\n\nThe inverse operation of factorizing AxesDimensions into dims and scale can be performed via normdims and dimscale.\n\ndims can be a tuple of AxisDimensions or a tuple of Vectors of AbstractDimensions. If scale == NoDims, it can be omitted.\n\nBy default, dims are scaled by a scalar factor so that their first element is NoDims. If you are absolutely sure that dims already satisfy this condition, you may set normalize = false for performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.AxisDimensions-Tuple{AbstractVector{<:AbstractDimensions}}","page":"API","title":"UnitfulTensors.AxisDimensions","text":"AxisDimensions(dims::AbstractVector; normalize = true)\nAxisDimensions(dims::AbstractVector{<:AbstractDimensions}; normalize = true)\n\nConvert an AbstractVector of AbstractDimensions to AxisDimensions.\n\nBy default, the dimensions are scaled by a scalar factor so that the first element of AxisDimensions is NoDims. If you are absolutely sure that dims already satisfy this condition, you may set normalize = false for performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Functions-2","page":"API","title":"‚Äã‚ÄÅFunctions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"values(::AbstractUnitfulTensor)\ndimensions(::AbstractUnitfulTensor)\nnormdims\ndimscale\ndimsplat\ndimsvec\nnodims\ntensor_product\ntensor_factorize\nishomogeneous\nissquareable\nisendomorphic\nmatch(::AbstractAxisDimensions, ::AbstractAxisDimensions)\nunits_off\ntensorize_literals","category":"page"},{"location":"api/#Base.values-Tuple{AbstractUnitfulTensor}","page":"API","title":"Base.values","text":"values(A::AbstractUnitfulTensor)\n\nGet the numerical values of an AbstractUnitfulTensor in the default unit system (SI).\n\nSee also: dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.FastQuantities.dimensions-Tuple{AbstractUnitfulTensor}","page":"API","title":"UnitfulTensors.FastQuantities.dimensions","text":"dimensions(A::AbstractUnitfulTensor)\n\nGet the physical dimensions of an AbstractUnitfulTensor.\n\nSee also: values.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.normdims","page":"API","title":"UnitfulTensors.normdims","text":"normdims(x::AbstractAxesDimensions)\nnormdims(x::AbstractAxisDimensions)\nnormdims(x::AbstractDimensions)\nnormdims(x::AbstractUnitfulTensor)\n\nGet a tuple of AbstractAxisDimensions representing the physical dimensions of x along each axis.\n\nAbstractAxisDimensions are normalized so that their first element is NoDims. The scalar normalization factor can be retrieved via dimscale(x).\n\nFor example, if x isa AbstractMatrixDimensions, normdims returns its row and column dimensions, and the elements of x satisfy x[i, j] == dimscale(x) * normdims(x)[1][i] * normdims(x)[2][j].\n\nAbstractAxisDimensions and AbstractDimensions are treated as 1- and 0-dimensional AbstractAxesDimensions, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.dimscale","page":"API","title":"UnitfulTensors.dimscale","text":"dimscale(x::AbstractAxesDimensions)\ndimscale(x::AbstractAxisDimensions)\ndimscale(x::AbstractDimensions)\ndimscale(x::AbstractUnitfulTensor)\n\nGet the first element of x.\n\nAbstractAxesDimensions are factorized into an overall scalar factor, retrieved by dimscale, and zero or more AbstractAxisDimensions, which represent the physical dimensions along each axis. AbstractAxisDimensions are normalized so that their first element is NoDims and can be retrieved via normdims(x). Normalization ensures that the factorization is unique.\n\nFor example, if x isa AbstractMatrixDimensions, the elements of x satisfy x[i, j] == dimscale(x) * normdims(x)[1][i] * normdims(x)[2][j].\n\nAbstractAxisDimensions and AbstractDimensions are treated as 1- and 0-dimensional AbstractAxesDimensions, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.dimsplat","page":"API","title":"UnitfulTensors.dimsplat","text":"dimsplat(x)\n\nReturn dimscale(x) and all normdims(x) as a single tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.dimsvec","page":"API","title":"UnitfulTensors.dimsvec","text":"dimsvec(a::AbstractAxisDimensions)\n\nConvert AbstractAxisDimensions to a Vector of AbstractDimensions.\n\nFor AxisDimensions, dimsvec returns the normdims field.\n\nwarning: Warning\nDon't mutate it, or it will affect any UnitfulTensor that references this AxisDimensions internally. Instead, create a copy if necessary.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.nodims","page":"API","title":"UnitfulTensors.nodims","text":"nodims(size...)\n\nCreate AxesDimensions representing the physical dimensions of a dimensionless array of size size.\n\nExamples\n\njulia> nodims(2, 3)\n2√ó3 AxesDimensions{2, SIDimensions}:\n NoDims  NoDims  NoDims\n NoDims  NoDims  NoDims\n\njulia> UnitfulTensor([1 2 3; 4 5 6], ùêç * nodims(2, 3))\n2√ó3 UnitfulMatrix{Int64, SIDimensions, Matrix{Int64}, AxesDimensions{2, SIDimensions}}:\n 1 mol  2 mol  3 mol\n 4 mol  5 mol  6 mol\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.tensor_product","page":"API","title":"UnitfulTensors.tensor_product","text":"tensor_product(xs::AbstractAxesDimensionsLike...; init = NoDims)\n\nCompute the tensor product of AbstractAxesDimensions, AbstractAxisDimensions, or AbstractDimensions.\n\nIf the argument list may be empty, the init keyword must be supplied (NoDims if one works with SIDimensions). ‚äó can be used as a shorthand.\n\nExamples:\n\njulia> ùêã ‚äó AxisDimensions([NoDims, ùêå]) ‚äó AxisDimensions([NoDims, ùêì])\n2√ó2 AxesDimensions{2, SIDimensions}:\n   ùêã    ùêã ùêì\n ùêã ùêå  ùêã ùêå ùêì\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.tensor_factorize","page":"API","title":"UnitfulTensors.tensor_factorize","text":"tensor_factorize(A::AbstractAxesDimensions, factor_ndims::Tuple{Vararg{Int}})\n\nRepresent A as dimscale(A) ‚äó factors[1] ‚äó factors[2] ‚äó ..., where dimscale(factors[i]) == NoDims and ndims.(factors) == factor_ndims.\n\nReturns (factors, dimscale(A)).\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.ishomogeneous","page":"API","title":"UnitfulTensors.ishomogeneous","text":"ishomogeneous(A::AbstractUnitfulTensor[, d::Integer]) -> Bool\nishomogeneous(A::AbstractAxesDimensions[, d::Integer]) -> Bool\nishomogeneous(A::AbstractArray{<:Number}[, d::Integer]) -> Bool\nishomogeneous(A::AbstractAxisDimensions) -> Bool\n\nTest whether an array is dimensionally homogeneous (all of its elements have the same physical dimensions).\n\nd can be provided to test homogeneity along a specific (mathematical) dimension.\n\nMost of linear algebra can be applied to dimensionally homogeneous matrices. Notable functions that require homogeneity include svd and norm. Least-squares solution of an overdetermined system with \\ or pinv requires homogeneity along the first dimension; otherwise the sum of squares is undefined.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.issquareable","page":"API","title":"UnitfulTensors.issquareable","text":"issquareable(A::AbstractUnitfulMatrix) -> Bool\nissquareable(A::AbstractMatrixDimensions) -> Bool\nissquareable(A::AbstractMatrix{<:Number}) -> Bool\n\nTest whether a matrix can be squared.\n\nCertain functions, such as eigen and tr, are defined only for squareable matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.isendomorphic","page":"API","title":"UnitfulTensors.isendomorphic","text":"isendomorphic(A::AbstractUnitfulMatrix) -> Bool\nisendomorphic(A::AbstractMatrixDimensions) -> Bool\nisendomorphic(A::AbstractMatrix{<:Number}) -> Bool\n\nTest whether a matrix is endomorphic (can represent a linear map from a vector space to itself).\n\nTranscendental functions, such as exp and log, are defined only for endomorphic matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.match-Tuple{AbstractAxisDimensions, AbstractAxisDimensions}","page":"API","title":"Base.match","text":"match(a::AbstractAxisDimensions, b::AbstractAxisDimensions)\n\nCheck if two AbstractAxisDimensions can be multiplied.\n\nThis function is used for dimensions checking in AbstractUnitfulMatrix multiplication.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnitfulTensors.units_off","page":"API","title":"UnitfulTensors.units_off","text":"units_off()\n\nSwitch from UnitfulScalars and UnitfulTensors to plain numbers and arrays of numbers, as if this package was not loaded.\n\nIf you are concerned with the overhead of using unitful quantities:\n\nRun your code on a small-scale problem to check the units\nCall units_off() immediately after using UnitfulTensors\nRun your code on the actual large-scale problem\n\nIf you used UnitfulScalar(...), UnitfulTensor(...), and the number * u\"unit\" syntax for constructing unitful quantities, units_off() should eliminate all runtime overhead. Quantities are still converted to the default units (SI) upon construction, but then the units are stripped and the rest of the execution proceeds with plain numbers.\n\nHowever, inner constructors like UnitfulScalar{Float64, SIDimensions}(1., ùêì) will still produce unitful quantities, so don't use them.\n\nThere is no units_on switch at present. You will have to restart Julia if you need units again.\n\nExamples\n\nusing UnitfulTensors, BenchmarkTools\n\n13u\"cm\" |> println\ntypeof(13u\"cm\") |> println\nu = UnitfulTensor([1u\"eV\", 2u\"ns\", 3u\"ŒºF\"])\nv = [1.602176634e-19, 1e-9, 3e-6]\n@btime $v * $v'\n@btime $u * $u'\n\nunits_off()\nprintln()\n\n13u\"cm\" |> println\ntypeof(13u\"cm\") |> println\nu = UnitfulTensor([1u\"eV\", 2u\"ns\", 3u\"ŒºF\"])\nv = [1.602176634e-19, 1e-9, 3e-6]\n@btime $v * $v'\n@btime $u * $u'\n\n# output\n\n0.13 m\nUnitfulScalar{Float64, SIDimensions}\n  73.610 ns (1 allocation: 128 bytes)\n  80.519 ns (1 allocation: 128 bytes)\n\n0.13\nFloat64\n  73.561 ns (1 allocation: 128 bytes)\n  73.077 ns (1 allocation: 128 bytes)\n\n3√ó3 Matrix{Float64}:\n 2.56697e-38  3.20435e-28  4.80653e-25\n 3.20435e-28  4.0e-18      6.0e-15\n 4.80653e-25  6.0e-15      9.0e-12\n\n\n\n\n\n","category":"function"},{"location":"api/#UnitfulTensors.tensorize_literals","page":"API","title":"UnitfulTensors.tensorize_literals","text":"tensorize_literals()\n\nMake array literals involving AbstractUnitfulScalars return UnitfulTensors instead of Arrays, so that you don't have to write UnitfulTensor([...]) all the time.\n\nThis feature is experimental. It might break something and may be removed in the future.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.esm.min.mjs';\n  mermaid.initialize({ startOnLoad: true });\n</script>","category":"page"},{"location":"#UnitfulTensors.jl","page":"Home","title":"UnitfulTensors.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for working efficiently with arrays of physical quantities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently it is experimental and mostly focused on linear algebra.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support for arrays with mixed units\nIndexing and assignment: scalar indices, multidimensional indices, logical indexing, omitted/trailing singleton dimensions\nArithmetic: +, -, *, \\, /, ^, sqrt, dot, cross, kron, inv, pinv, lmul!, rmul!, ldiv!, rdiv!\nTranscendental functions of matrices\nadjoint, transpose\ndet, logdet, logabsdet, tr\nFactorizations: lu, bunchkaufman, cholesky, ldlt, eigen, hessenberg, schur, svd, lq, qr\nNorm and related functions: cond, condskeel, norm, normalize, nullspace, opnorm, rank\nRotations and reflections: rotate!, reflect!, givens\nSolving Lyapunov and Sylvester equations\nSupport for sparse matrices\nModerate runtime overhead, often negligible\nZero-overhead mode with units_off: check the units on a small-scale problem > turn them off > proceed with a large-scale problem","category":"page"},{"location":"","page":"Home","title":"Home","text":"Not implemented yet:","category":"page"},{"location":"","page":"Home","title":"Home","text":"General array manipulation: hcat, vcat, repeat, reshape, permutedims, sort, etc.\nElementwise operations","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future plans:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add support for frames of reference\nFurther optimizations: NoAxisDimensions, InverseAxisDimensions, memoization\nReplace FastQuantities with DynamicQuantities.jl\nTullio.jl/TensorCast.jl integration","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add using UnitfulTensors at the top of your script\nAdd units to your inputs and constants: ƒß = 1.054571817e-34 * u\"J*s\"\nCreate UnitfulTensors instead of arrays: UnitfulTensor([1u\"s\" 2u\"m\"; 3u\"m\" 4u\"m^2/s\"])\nNow linear algebra functions should just work","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Guide for more details.","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using UnitfulTensors, LinearAlgebra\n\n# h-parameters\nH = UnitfulTensor([3.7u\"kŒ©\" 1.3e-4\n                   120      8.7u\"ŒºS\"])\nZ‚Çõ = 50u\"Œ©\" # Source impedance\nY‚Çó = 20u\"mS\" # Load admittance\nH‚Çõ = deepcopy(H)\nH‚Çõ[1, 1] += Z‚Çõ\nZout = inv(H‚Çõ)[2, 2] # Output impedance\nH‚Çõ‚Çó = H + Diagonal(UnitfulTensor([Z‚Çõ, Y‚Çó]))\nG‚Çú = 4 * Z‚Çõ * Y‚Çó * (H‚Çõ‚Çó[2, 1] / det(H‚Çõ‚Çó))^2 # Transducer power gain\nG‚Çú‚ÇÇ = 4 * Z‚Çõ * Y‚Çó * (inv(H‚Çõ‚Çó)[2, 1])^2 # Equivalent expression\nprintln((Zout, value(Zout), Zout/1u\"kŒ©\"))\nprintln((G‚Çú, G‚Çú‚ÇÇ))\n\n# output\n\n(220264.31718061675 kg m^2 A^-2 s^-3, 220264.31718061675, 220.26431718061676)\n(10.2353526224919, 10.2353526224919)","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"#Dense-33-matrix","page":"Home","title":"Dense 3√ó3 matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using UnitfulTensors, BenchmarkTools\n        \nN = 3\n\nA = randn(N, N)\nb = randn(N)\n\nuA = UnitfulTensor(A, ùêã * nodims(N, N))\nub = UnitfulTensor(b, ùêå * nodims(N))\n\nprintln(\"Matrix * vector:\")\n@btime $A * $b\n@btime $uA * $ub\nprintln(\"Matrix * matrix:\")\n@btime $A * $A\n@btime $uA * $uA\nprintln(\"Solving a linear system:\")\n@btime $A \\ $b\n@btime $uA \\ $ub\n\n# output\n\nMatrix * vector:\n  119.563 ns (1 allocation: 80 bytes)\n  160.231 ns (1 allocation: 80 bytes)\nMatrix * matrix:\n  82.297 ns (1 allocation: 128 bytes)\n  115.884 ns (1 allocation: 128 bytes)\nSolving a linear system:\n  671.548 ns (3 allocations: 288 bytes)\n  861.569 ns (5 allocations: 576 bytes)","category":"page"},{"location":"#Laplacian-on-a-1010-grid,-dense-and-sparse","page":"Home","title":"Laplacian on a 10√ó10 grid, dense and sparse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using UnitfulTensors, LinearAlgebra, SparseArrays, BenchmarkTools\n\nNx = 10\nN = Nx^2\n\nŒî1d = Tridiagonal(fill(1., Nx - 1), fill(-2., Nx), fill(1., Nx - 1))\nùüô = I(Nx)\n\nŒî = kron(Œî1d, ùüô) + kron(ùüô, Œî1d)\nŒîs = sparse(Œî)\nœÅ = randn(N)\n\nuŒî = UnitfulTensor(Œî, ùêã^-2 * nodims(N, N))\nuŒîs = UnitfulTensor(Œîs, ùêã^-2 * nodims(N, N))\nuœÅ = UnitfulTensor(œÅ * u\"C/m^3\")\n\nprintln(\"Matrix * vector:\")\n@btime $Œî * $œÅ\n@btime $uŒî * $uœÅ\n@btime $Œîs * $œÅ\n@btime $uŒîs * $uœÅ\nprintln(\"Matrix * matrix:\")\n@btime $Œî * $Œî\n@btime $uŒî * $uŒî\n@btime $Œîs * $Œîs\n@btime $uŒîs * $uŒîs\nprintln(\"Solving a linear system:\")\n@btime $Œî \\ $œÅ\n@btime $uŒî \\ $uœÅ\n@btime $Œîs \\ $œÅ\n@btime $uŒîs \\ $uœÅ\n\n# output\n\nMatrix * vector:\n  1.618 Œºs (1 allocation: 896 bytes)\n  2.038 Œºs (1 allocation: 896 bytes)\n  755.763 ns (1 allocation: 896 bytes)\n  1.128 Œºs (1 allocation: 896 bytes)\nMatrix * matrix:\n  56.211 Œºs (2 allocations: 78.17 KiB)\n  57.104 Œºs (2 allocations: 78.17 KiB)\n  16.128 Œºs (6 allocations: 35.50 KiB)\n  16.492 Œºs (6 allocations: 35.50 KiB)\nSolving a linear system:\n  150.873 Œºs (4 allocations: 79.92 KiB)\n  153.623 Œºs (6 allocations: 85.67 KiB)\n  455.481 Œºs (125 allocations: 253.85 KiB)\n  455.188 Œºs (127 allocations: 259.60 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Naively one could expect a 8x slowdown because 8 numbers are required to describe a single unitful scalar (1 for the numerical value, 7 for dimensions). This is not the case because","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dimensions of a UnitfulTensor are of tensor product form, so only about 7*(M + N) numbers are required to describe the dimensions of an M√óN matrix.\nOperations on dimensions are usually simpler then on numerical values. Multiplication of two N√óN dense matrices requires O(N^3) operations on values and O(N) operations on dimensions.\nMost linear algebra functions reuse the dimensions of their arguments. For example, matrix multiplication copies row dimensions from the first argument and column dimensions from the last argument. In such cases, only the references to the corresponding AxisDimensions are copied from one UnitfulTensor to another, not the AxisDimensions themselves.\nOther operations invert AxisDimensions (inv, \\) or introduce a dimensionally homogeneous axis (eigvecs), so they can be sped up by implementing NoAxisDimensions and InverseAxesDimensions (not implemented yet).\nExponents of SI base units are usually rational numbers with small numerators and denominators, mostly integers and occasional half-integers. UnitfulTensors.jl stores them as Float32 instead of Float64, and even smaller options can be considered.\nPhysical dimensions are usually far less diverse than numerical values, so memoization may be beneficial (not implemented yet).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The most popular Julia package for working with unitful quantities is Unitful.jl. It stores units in type parameters in an attempt to move unit computation to the compilation stage. This doesn't work well in the case of dimensionally heterogeneous arrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"UnitfulTensors.jl has a FastQuantities submodule, which defines a type SIDimensions, which stores the physical dimensions of a UnitfulScalar as 7 Float32 numbers. The speedup is noticeable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnitfulTensors, BenchmarkTools\nusing Unitful: @u_str as @uf_str\n\nN = 1000\n\nu = [1. * u\"s\"^i for i in 1:N]\nv = [1. * uf\"s\"^i for i in 1:N] \n\nprintln(\"FastQuantities\")\n@btime $u .* $u\nprintln(\"Unitful.jl\")\n@btime $v .* $v\n\n# output\n\nFastQuantities\n  4.073 Œºs (2 allocations: 39.11 KiB)\nUnitful.jl\n  1.735 ms (1024 allocations: 32.44 KiB)","category":"page"},{"location":"#Brief-API-overview","page":"Home","title":"Brief API overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"flowchart TD\n    U(\"U::UnitfulTensor\")\n    V(\"V::AbstractArray\")\n    D(\"D::AxesDimensions\")\n    S(\"S::SIDimensions\")\n    T(\"T::NTuple{AxisDimensions}\")\n    A1(\"A1::AxisDimensions\")\n    A2(\"A2::AxisDimensions\")\n    V1(\"V1::Vector{SIDimensions}\")\n    V2(\"V2::Vector{SIDimensions}\")  \n    US(\"U[i, j]::UnitfulScalar\")\n    VS(\"V[i, j]::Number\")\n    DS(\"D[i, j]::SIDimensions\\n == S*A1[i]*A2[j]\\n == S*V1[i]*V2[j]\")\n    U --\"values\"--> V\n    U --\"dimensions\"--> D\n    D --\"dimscale\"--> S\n    D --\"normdims\"--> T\n    T --> A1 & A2\n    A1 --\"dimsvec\"--> V1\n    A2 --\"dimsvec\"--> V2\n    U -.\"getindex\".-> US\n    US --\"value\"--> VS\n    US --\"dimensions\"--> DS","category":"page"},{"location":"","page":"Home","title":"Home","text":"UnitfulTensor represents an array of unitful quantities that can be used in linear or multilinear algebra. It stores an AbstractArray of numerical values and AxesDimensions that represent its physical dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the numerical values, you can use basic Array, sparse matrices, StaticArrays, etc., but not OffsetArrays or anything else with non-standard indexing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The physical dimensions must be of tensor product form, otherwise such an array couldn't be multiplied by any vector. For example, the dimensions of a UnitfulMatrix are the product of its row and column dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure that this decomposition is unique, the row and column dimensions are normalized (divided by scalar factors so that the first row and column dimensions are NoDims). The combined normalization factor is stored as a separate field that can be accessed via dimscale, while the dimensions along each axis are stored as AxisDimensions objects and can be accessed via normdims.","category":"page"},{"location":"#Related-work","page":"Home","title":"Related work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia: Goretkin, Gebbie, more\nIn C++: Withopf, Withopf, Withopf, Withopf, Withopf on Sea, Withopf, Withopf\nIn the 90s: Hart","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
